# -*- Makefile -*-
# Makefile for source package: kernel
#
# Author: Cristian Gafton <gafton@amazon.com>
#
# Module created by 'gafton' on 2012-01-19

ifeq ($(GIT),)
$(error Makefile.common must be included before this Makefile)
endif

TAREXT		= .tar.gz

# This is used to generate files for a src.rpm file containing a "vanilla"
# linux kernel archive plus patches. The following defines are needed for this
# to work:
#
# linux_TAGVER
#    the basic version of the kernel, required for tarball names.
# linux_TAR_BASE
#    this defines the tag/commitid which will be used to generate
#    the tarball archive
# linux_PATCH_BASE
#    this defines the tag/commitid used as the floor in the
#    generation of PatchN: and ApplyPatch: lines
# linux_PATCH_HEAD
#    tag/commitid upto which patches are extracted for the PatchN: and
#    ApplyPatch: lines. The linux_PATCH_HEAD can be the name of a branch
#    rooted at linux_TAR_BASE. linux_PATCH_BASE or some other tag/commit-id.
# linux_GIT
#    where to find the git repository of the linux kernel source tree that
#    contains the above tags/branches/commitids

#
# Operation:
#
# * The linux_TAR_BASE is archived and a tarball with TAREXT is created. This
#   is substituted as SOURCE0 in the template file.
# * Every commit between linux_TAR_BASE and linux_PATCH_BASE is generated by
#   git format-patch and then are archived into a tarball which is then
#   replaced as the SOURCE1 in the template kernel spec file.
# * Every commit between linux_PATCH_BASE and linux_PATCH_HEAD are generated
#   as PatchN: and ApplyPatch lines in the template spec file

# Other module-specific defines are:
# *_PREFIX	- the name of the top level directory for the tarball
# *_TAR		- name of the tarball archive filename that will get generated
# *_BRANCH	- default branch that shoule be checked out
# *_GIT		- git repository url for this module

include linux.vers
# defines for archive building
linux_PREFIX	= linux-$(linux_TAGVER)

linux_TAR_ball	 = linux-$(linux_TAGVER)
linux_PATCH_ball = linux-$(linux_TAGVER)-patches

linux_GIT	= $(shell $(get_fetch_base))/linux.git

%/.update : %/.git Makefile.kernel Makefile | %
	pushd $* ; $(GIT) clean -f -d -x
	pushd $* ; $(if $($*_BRANCH),$(call checkout-branch,$($*_BRANCH)),true)
	touch $@

tarballs : $(addprefix $(SOURCEDIR)/,$(addsuffix $(TAREXT),$(linux_TAR_ball) $(linux_PATCH_ball)))
sources : tarballs

$(SOURCEDIR)/%.tar.bz2: %.tar | $(SOURCEDIR)
	bzip2 -f -c $< > $@

$(SOURCEDIR)/%.tar.gz: %.tar | $(SOURCEDIR)
	gzip -f -c $< > $@

# extracting source code...
linux :
	$(GIT) clone --no-hardlinks $($@_GIT) $@
$(linux_TAR_ball).tar : linux/.git $(MAKEFILE_LIST) | linux
	$(GIT) archive --format=tar --prefix $(linux_PREFIX)/ --remote=linux $(linux_TAR_BASE) > $@
$(linux_PATCH_ball).tar : linux/.git $(MAKEFILE_LIST) | linux
	pushd linux ; $(GIT) format-patch -N -k -o $(SOURCEDIR) $(linux_TAR_BASE)..$(linux_PATCH_BASE) | \
	xargs -r -l1 basename >$(SOURCEDIR)/$@.list ; \
	popd ; \
	tar cf $@ -C $(SOURCEDIR) --remove-files --files-from=$(SOURCEDIR)/$@.list $@.list

#
# KERNEL SRC/RPM BUILDING SUPPORT
#
HEADLOG		= $(SOURCEDIR)/head.log
APPLYLOG	= $(SOURCEDIR)/apply.log
PATCHLOG	= $(SOURCEDIR)/patch.log

GITDIRS		= linux/.git

$(CUSTOMSPEC) : $(HEADLOG)

# extract the top level changelog entry that summarizes the makeup of this build
# $1 : the directory to change to
# $2 : what name to use for this module
# $3..$4 : git commit id range, if any
define get_changelist
{ TZ=UTC ; \
pushd $(1)>/dev/null ; \
$(GIT) log --date=short --format=tformat:"  - $(2)/%H $(if $(3),$(3)..$(4):)" $(4) -1 ; \
$(GIT) log --date=short --format=tformat:"    - [%h] [%ad] %s (%ae)" $(if $(3),$(3)..$(4),-10) ; \
echo ; \
popd >/dev/null ; }
endef

$(HEADLOG): $(GITDIRS) $(MAKEFILE_LIST)
	TZ=UTC echo "* $$(date +'%a %b %d %Y') Builder <builder@amazon.com>" > $@
	$(call get_changelist,.,kernel,HEAD^) >> $@
	$(call get_changelist,linux,linux,$(linux_PATCH_BASE),$(linux_PATCH_HEAD)) >>$@

$(PATCHLOG) : linux/.git $(MAKEFILE_LIST)
	cd linux ; $(GIT) format-patch -k -o $(SOURCEDIR) -N $(linux_PATCH_BASE)..$(linux_PATCH_HEAD) |\
		xargs -r -l1 basename >$@
	sed -i "s/^\(....\)-/Patch\1: \1-/" $@
$(APPLYLOG) : $(PATCHLOG)
	sed "s,.*:,ApplyPatch," <$< >$@

clean ::
	rm -fv $(HEADLOG) $(APPLYLOG) $(PATCHLOG)

# redefine spec file generation to include git logs from submodules
define replace_changelog
$(call get_specfile_changelog,$<) > .cl.spec
$(call get_gitlog_changelog,$(CHANGELOGS)) > .cl.gitlog
pushd linux >/dev/null; $(call get_gitlog_changelog,,$(linux_BASE),$(linux_HEAD)) > ../.cl.linux; popd>/dev/null
$(find-common-dir)/sort-changelog.py .cl.spec .cl.gitlog .cl.linux > .cl && \
	rm -f .cl.spec .cl.gitlog .cl.linux
sed -i -e "/^%changelog/Iq" $@
sed -i -e "/^%changelog/ r .cl" $@ && rm -f .cl
sed -i -e "/^%changelog/ r $(HEADLOG)" $@ && rm -f $(HEADLOG)
endef

specfile sources : add-patches | $(CUSTOMSPEC)
add-patches :  $(CUSTOMSPEC) $(APPLYLOG) $(PATCHLOG)
	sed -i  -e '/__PATCHFILE_TEMPLATE__/ r $(PATCHLOG)' \
		-e '/__APPLYFILE_TEMPLATE__/ r $(APPLYLOG)' \
		$(CUSTOMSPEC)
specfile sources : update-sources | $(CUSTOMSPEC) tarballs
update-sources : $(CUSTOMSPEC) tarballs $(MAKEFILE_LIST)
	sed -i -r -e "s/^Source0:.*$$/Source0: $(linux_TAR_ball)$(TAREXT)/i" \
		  -e "s/^Source1:.*$$/Source1: $(linux_PATCH_ball)$(TAREXT)/i" $<

git-push : git-push-linux

git-push-linux : linux/.git
	pushd linux ; git push origin $(linux_BRANCH):refs/heads/$(linux_BRANCH) ; git push origin --tags ; popd

clean ::
	rm -fv linux.tar $(linux_TAR) *$(TAREXT)

.SECONDARY : $(linux_TAR)

.PHONY:


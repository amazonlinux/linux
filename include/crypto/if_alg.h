/* SPDX-License-Identifier: GPL-2.0-or-later */
/*
 * if_alg: User-space algorithm interface
 *
 * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
 */

#ifndef _CRYPTO_IF_ALG_H
#define _CRYPTO_IF_ALG_H

#include <crypto/api.h>
#include <linux/compiler.h>
#include <linux/completion.h>
#include <linux/if_alg.h>
#include <linux/scatterlist.h>
#include <linux/types.h>
#include <linux/atomic.h>
#include <net/sock.h>

#include <crypto/aead.h>
#include <crypto/skcipher.h>

#define ALG_MAX_PAGES			16

struct alg_sock {
	/* struct sock must be the first member of struct alg_sock */
	struct sock sk;

	struct sock *parent;

	atomic_t refcnt;
	atomic_t nokey_refcnt;

	const struct af_alg_type *type;
	void *private;
};

struct af_alg_control {
	struct af_alg_iv *iv;
	int op;
	unsigned int aead_assoclen;
};

struct af_alg_type {
	void *(*bind)(const char *name, u32 type, u32 mask);
	void (*release)(void *private);
	int (*setkey)(void *private, const u8 *key, unsigned int keylen);
	int (*setentropy)(void *private, sockptr_t entropy, unsigned int len);
	int (*accept)(void *private, struct sock *sk);
	int (*accept_nokey)(void *private, struct sock *sk);
	int (*setauthsize)(void *private, unsigned int authsize);

	struct proto_ops *ops;
	struct proto_ops *ops_nokey;
	struct module *owner;
	char name[14];
};

struct af_alg_sgl {
	struct sg_table sgt;
	struct scatterlist sgl[ALG_MAX_PAGES + 1];
	bool need_unpin;
};

/* TX SGL entry */
struct af_alg_tsgl {
	struct list_head list;
	unsigned int cur;		/* Last processed SG entry */
	struct scatterlist sg[];	/* Array of SGs forming the SGL */
};

#define MAX_SGL_ENTS ((4096 - sizeof(struct af_alg_tsgl)) / \
		      sizeof(struct scatterlist) - 1)

/* RX SGL entry */
struct af_alg_rsgl {
	struct af_alg_sgl sgl;
	struct list_head list;
	size_t sg_num_bytes;		/* Bytes of data in that SGL */
};

/**
 * struct af_alg_async_req - definition of crypto request
 * @iocb:		IOCB for AIO operations
 * @sk:			Socket the request is associated with
 * @first_rsgl:		First RX SG
 * @last_rsgl:		Pointer to last RX SG
 * @rsgl_list:		Track RX SGs
 * @tsgl:		Private, per request TX SGL of buffers to process
 * @tsgl_entries:	Number of entries in priv. TX SGL
 * @outlen:		Number of output bytes generated by crypto op
 * @areqlen:		Length of this data structure
 * @cra_u:		Cipher request
 */
struct af_alg_async_req {
	struct kiocb *iocb;
	struct sock *sk;

	struct af_alg_rsgl first_rsgl;
	struct af_alg_rsgl *last_rsgl;
	struct list_head rsgl_list;

	struct scatterlist *tsgl;
	unsigned int tsgl_entries;

	unsigned int outlen;
	unsigned int areqlen;

	union {
		struct aead_request aead_req;
		struct skcipher_request skcipher_req;
	} cra_u;

	/* req ctx trails this struct */
};

/**
 * struct af_alg_ctx - definition of the crypto context
 *
 * The crypto context tracks the input data during the lifetime of an AF_ALG
 * socket.
 *
 * @tsgl_list:		Link to TX SGL
 * @iv:			IV for cipher operation
 * @state:		Existing state for continuing operation
 * @aead_assoclen:	Length of AAD for AEAD cipher operations
 * @completion:		Work queue for synchronous operation
 * @used:		TX bytes sent to kernel. This variable is used to
 *			ensure that user space cannot cause the kernel
 *			to allocate too much memory in sendmsg operation.
 * @rcvused:		Total RX bytes to be filled by kernel. This variable
 *			is used to ensure user space cannot cause the kernel
 *			to allocate too much memory in a recvmsg operation.
 * @more:		More data to be expected from user space?
 * @merge:		Shall new data from user space be merged into existing
 *			SG?
 * @enc:		Cryptographic operation to be performed when
 *			recvmsg is invoked.
 * @write:		True if we are in the middle of a write.
 * @init:		True if metadata has been sent.
 * @len:		Length of memory allocated for this data structure.
 * @inflight:		Non-zero when AIO requests are in flight.
 */
struct af_alg_ctx {
	struct list_head tsgl_list;

	void *iv;
	void *state;
	size_t aead_assoclen;

	struct crypto_wait wait;

	size_t used;
	atomic_t rcvused;

	bool		more:1,
			merge:1,
			enc:1,
			write:1,
			init:1;

	unsigned int len;

	unsigned int inflight;
};

DECLARE_CRYPTO_API(CONFIG_CRYPTO_USER_API, af_alg_register_type, int,
	(const struct af_alg_type *type),
	(type));

DECLARE_CRYPTO_API(CONFIG_CRYPTO_USER_API, af_alg_unregister_type, int,
	(const struct af_alg_type *type),
	(type));

DECLARE_CRYPTO_API(CONFIG_CRYPTO_USER_API, af_alg_release, int,
	(struct socket *sock),
	(sock));

DECLARE_CRYPTO_API(CONFIG_CRYPTO_USER_API, af_alg_release_parent, void,
	(struct sock *sk),
	(sk));

DECLARE_CRYPTO_API(CONFIG_CRYPTO_USER_API, af_alg_accept, int,
	(struct sock *sk, struct socket *newsock, struct proto_accept_arg *arg),
	(sk, newsock, arg));

DECLARE_CRYPTO_API(CONFIG_CRYPTO_USER_API, af_alg_free_sg, void,
	(struct af_alg_sgl *sgl),
	(sgl));

static inline struct alg_sock *alg_sk(struct sock *sk)
{
	return (struct alg_sock *)sk;
}

/**
 * Size of available buffer for sending data from user space to kernel.
 *
 * @sk socket of connection to user space
 * @return number of bytes still available
 */
static inline int af_alg_sndbuf(struct sock *sk)
{
	struct alg_sock *ask = alg_sk(sk);
	struct af_alg_ctx *ctx = ask->private;

	return max_t(int, max_t(int, sk->sk_sndbuf & PAGE_MASK, PAGE_SIZE) -
			  ctx->used, 0);
}

/**
 * Can the send buffer still be written to?
 *
 * @sk socket of connection to user space
 * @return true => writable, false => not writable
 */
static inline bool af_alg_writable(struct sock *sk)
{
	return PAGE_SIZE <= af_alg_sndbuf(sk);
}

/**
 * Size of available buffer used by kernel for the RX user space operation.
 *
 * @sk socket of connection to user space
 * @return number of bytes still available
 */
static inline int af_alg_rcvbuf(struct sock *sk)
{
	struct alg_sock *ask = alg_sk(sk);
	struct af_alg_ctx *ctx = ask->private;

	return max_t(int, max_t(int, sk->sk_rcvbuf & PAGE_MASK, PAGE_SIZE) -
		     atomic_read(&ctx->rcvused), 0);
}

/**
 * Can the RX buffer still be written to?
 *
 * @sk socket of connection to user space
 * @return true => writable, false => not writable
 */
static inline bool af_alg_readable(struct sock *sk)
{
	return PAGE_SIZE <= af_alg_rcvbuf(sk);
}

DECLARE_CRYPTO_API(CONFIG_CRYPTO_USER_API, af_alg_count_tsgl, unsigned int,
	(struct sock *sk, size_t bytes, size_t offset),
	(sk, bytes, offset));

DECLARE_CRYPTO_API(CONFIG_CRYPTO_USER_API, af_alg_pull_tsgl, void,
	(struct sock *sk, size_t used, struct scatterlist *dst, size_t dst_offset),
	(sk, used, dst, dst_offset));

DECLARE_CRYPTO_API(CONFIG_CRYPTO_USER_API, af_alg_wmem_wakeup, void,
	(struct sock *sk),
	(sk));

DECLARE_CRYPTO_API(CONFIG_CRYPTO_USER_API, af_alg_wait_for_data, int,
	(struct sock *sk, unsigned flags, unsigned min),
	(sk, flags, min));

DECLARE_CRYPTO_API(CONFIG_CRYPTO_USER_API, af_alg_sendmsg, int,
	(struct socket *sock, struct msghdr *msg, size_t size, unsigned int ivsize),
	(sock, msg, size, ivsize));

DECLARE_CRYPTO_API(CONFIG_CRYPTO_USER_API, af_alg_free_resources, void,
	(struct af_alg_async_req *areq),
	(areq));

DECLARE_CRYPTO_API(CONFIG_CRYPTO_USER_API, af_alg_async_cb, void,
	(void *data, int err),
	(data, err));

DECLARE_CRYPTO_API(CONFIG_CRYPTO_USER_API, af_alg_poll, __poll_t,
	(struct file *file, struct socket *sock, poll_table *wait),
	(file, sock, wait));

DECLARE_CRYPTO_API(CONFIG_CRYPTO_USER_API, af_alg_alloc_areq, struct af_alg_async_req *,
	(struct sock *sk, unsigned int areqlen),
	(sk, areqlen));

DECLARE_CRYPTO_API(CONFIG_CRYPTO_USER_API, af_alg_get_rsgl, int,
	(struct sock *sk, struct msghdr *msg, int flags, struct af_alg_async_req *areq, size_t maxsize, size_t *outlen),
	(sk, msg, flags, areq, maxsize, outlen));

#endif	/* _CRYPTO_IF_ALG_H */

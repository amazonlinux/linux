Linux kernel driver for Elastic Network Adapter (ENA)
This network driver is speed-independent, providing a high-performance,
low-latency network interface for virtual machines and bare metal environment.
ENA negotiates supported features with the device, to enable future upgrades and
various systems with a single driver.

Files Structure:
===============
ena_com/ena_defs - Holds the ENA descriptors and ENA register structures.
ena_com - Communication layer. This layer is responsible for handling all
communications between the ENA device and the driver.
ena_netdev.c/.h - Main driver.

Arch:
====
This driver implements a standard Linux Ethernet driver. The kernel communicates
with the driver using the net_device_ops (defined at include/linux/netdevice.h).
the driver uses the PCI interface for probing the adapter and various other
management functions.

Management Interface:
====================
All management of the ENA device is performed by 2 queues.
The Admin queue (AQ) and the asynchronous event notification queue (AENQ).
The admin queue has the following commands:
* Create IO submission queue.
* Create IO completion queue.
* Destroy IO submission queue.
* Destroy IO completion queue.
* Suspend IO submission queue.
* Flush IO submission queue.
* Get feature.
* Set feature.
* Configure AENQ.
* Get statistics.

The create and and destroy commands are fully implemented. The get/set feature
is partially implemented and the rest of the commands will be implemented in a
later version.
To examine all the properties of the set/get feature command, refer to
ena_com/ena_defs/ena_admin_defs.h.

AENQ is a single-side queue (from the ENA device to the host driver), which
sends events that cannot be reported using the Admin Completion Queue (ACQ).
Each event is divided into group and syndrom.
The events are:
	Group		Syndrom                         Notes
	Link change	- X -
	Fatal error	- X -
	Warning		Thermal threshold		PF only
	Warning		Logging fifo overflow		PF only
	Warning		Dirty page logging		PF only
	Warning		Malicious mmio access		PF only
	Warning 	CQ full
	notification	suspend traffic
	notification	resume traffic
	Keep Alive	- X -

Currently the driver implements handlers for:
link change, suspend/resume trafic, keep alive tracking and fatal error.

Queue Operating Modes:
======================

The driver supports 2 Queue Operation modes for Transmit (Tx) queues:
* Low Latency Queue (LLQ) or push-mode.
 ** In this mode the driver pushes the transmit descriptors and the first 128
bytes of the packet directly to the ENA device memory space. The rest of the
packet payload is fetched by the device. For this operation mode the host use
a dedicated PCIe device memory BAR that is non-cacheable but with write-combine
enabled.

* Regular mode
** In this mode the ENA device fetches the ENA Tx descriptors and the packet
data from host memory.

For RX queues the ENA device supports only the regular mode.

***Note: Not all the ENA devices support LLQ, and this feature is negotiated
with the device upon initialization.

If the ENA device does not support LLQ mode, the driver will fall back to
regular mode.

Interrupt Modes:
================
The ENA device is built with modern muti-core and parallel processing in mind,
thus it has an interrupt controller that can generate an MSI-X interrupt per
queue.

The driver assigns a single MSI-X vector per queue pair (for both the Tx and the
Rx directions). In addition, the driver assigns another dedicated MSI-X
vector for management (for admin completions and asynchronous events
notification queues).

Management interrupt registration is performed when the Linux kernel probes the
adapter, and it is de-registered when the adapter is removed.
The I/O queues interrupts registeration is performed when the linux interface
of the adapter is opened, and it is de-registered when
the interface is closed. The systems interrupts status can be viewed in the
/proc/interrupts pseudo file.

The registered interrupt name is:
ena-mgmnt@pci:<pci device name of the adapter>
and for each queue, an interrupt is registered with the following name:
<interface name><queue index>.

Memory Allocations:
==================
DMA Coherent buffers for the following DMA rings:
- Tx submission ring (For regular mode; for LLQ mode it is allocated using
kzalloc)
- Tx completion ring.
- Rx submission ring.
- Rx completion ring.
- Admin submition ring.
- Admin completion ring.
- AENQ ring.
- MMIO Readless mechanisem buffer.

The ENA device admin, aenq and the mmio read and buffers are allocated on
probe and freed on termination.

Regular allocations:
- Tx buffers info ring.
- Tx free indexes ring.
- Rx buffers info ring.
- MSI-X table.
- ENA device.

Tx/Rx buffers and the MSI-X table are allocated on Open and freed on Close.

Rx buffer allocation modes:

The driver supports two allocation modes:
1. Frag allocation (default): Buffer is allocated using netdev_alloc_frag().
2. Page allocation: Buffer is allocated using alloc_page().

Rx buffers allocation in both modes is performed as follows:
1. When enabling an interface -- open().
2. Once per Rx poll for all the frames received and not copied to the new
   allocated SKB (len < small_packet_len).

These buffers are freed on close().

The small_packet_len is initialized by default to ENA_DEFAULT_SMALL_PACKET_LEN
and can be configured
by the sysfs pseudo file
/sys/bus/pci/devices/<pci device name of the adapter>/small_packet_len.

SKB:
The driver-allocated SKB for frames received from Rx handling using
NAPI context. The allocation method depends on size of the packet.
If the frame length is larger than small_packet_len,
build_skb() is used, otherwise netdev_alloc_skb_ip_align() is
used, the buffer content is copied (by CPU) to the skb and the buffer
is recycled.

MULTIQUEUE:
===========
The driver supports multiqueue mode for both Tx and Rx.
This mode has various benefits when queues are allocated to different CPU
cores/threads.
1. Reduced CPU/thread/process contention on a given Ethernet port, when
transmitting a packet.
2. Cache miss rate on transmit completion is reduced, particularly for data
cache lines
   that hold the sk_buff structures.
3. Increased process-level parallelism when handling received packets.
4. Increased data cache hit rate by steering kernel processing of packets to the
CPU, where the application thread consuming the packet is running.
5. In hardware interrupt re-direction.

RSS:
For TCP/UDP packets the ENA device calculates the 4-tuple and steers the packet
according to this value (module #queue). Other packets are steered to queue 0.

VFs steering:
To steer between VFs, the ENA device uses the least significant byte of the
destination MAC address to determain the VF index. ARP packets are passed to PF.
This logic will be fixed in the next releases.

Interrupts Affinity:
-------------------
To utilize the multiqueue benefits, the user must set the interrupts affinity of
each of the queue's pair.  The general recommendation is to have the interrupt
of Tx and Rx queues N routed to core N.

DATA PATH:
==========
Tx:
---
end_start_xmit() is called by the stack. This function does the following:
- map data buffers (skb->data and frags).
- Populate ena_buf for the push buffer (if the driver works in push mode.)
- Prepare ENA bufs for the remaining frags.
- Allocate a new request ID from the empty req_id ring (The request ID is the
index of the packet in the Tx ring. This is used for OOO TX completions.)
- Add the packet to the proper place in the Tx ring.
- Call ena_prepare_tx(), an ENA communication layer that converts the ena_bufs
  to ENA descriptors (and adds meta ENA descriptors when needed.)
  This function also copies the ENA descriptors and the push buffer to the
device
  memory space (depending on the working mode.)
- Write doorbell to ENA device.
- When the ENA device finishes sending the packet, a completion interrupt is
raised.
- The interrupt handler schedules NAPI.
- The ena_clean_tx_irq function is called. This function handles the completion
descriptors generated by the ENA,
  with a single completion descriptor per completed packet.
Retrives the req_id from the completion descriptor. Gets the tx_info of the
packet, according to the req_id. Unmaps the data buffers and returns req_id
to the empty requester-id ring.
  The function stops when the completion descriptors are completed or the
budget is reached.

Rx:
---
- When a packet is received by the ENA device, it is written to the host
memory, where the previous ENA RX buffer was allocated. The driver makes sure
to set the INT bit in each of the ENA Rx descriptors, so an interrupt will be
triggered (if unmasked )when a new packet is written to that descriptor.
- The interrupt handler schedules NAPI.
- The aena_clean_rx_irq function is called. This functions calls aena_rx_pkt(),
an ENA communication layer function, which returns the number of descriptors
used for a new unhandled packet, and zero if no new packet is found.
Then it calls the ena_clean_rx_irq() function.
- ena_eth_rx_skb checks packet length:
  If the packet is too small (len less than small_packet_len), the driver
allocates an SKB structure for the new packet, and copies the packet payload
into the SKB data buffer.
In this way the original data buffer is not passed to the stack and is reused
for the next Rx packets.
Otherwise the function unmaps the Rx buffer, then allocates he new SKB
structure and hooks the Rx buffer to the SKB frags.
  (*) Copying the packet payload into the SKB data buffer for short packets is
a common optimization in Linux network drivers.
This method saves allocating and mapping large buffers.
  (**) Allocating SKB on packet reception is also a common method, which has the
following benefits:
  (i) SKB is used and accessed immediately after allocation.
This reduces possible cache misses.
  (ii) The number of 'inuse' sk_buff can be reduced to the very minimum,
especially when packets are dropped by the stack.
- The new SKB is updated with the necessary information (protocol, checksum hw
calc result, etc), and then passed to the network stack, using the NAPI interface
function napi_gro_receive().

Note:
The Rx and Tx queues share the same interrut so for each interrupt issued by
the device both ena_clean_rx_irq and ena_clean_tx_irq will be called.

MMIO Readless mechanisem:
There are two new WO registers in the MMIO Regs.
Register Index - index of the register that should be read + coockie
MMIO Response Addr  (High/Low) address in Device Driver memory where the
response should be written by the device.
Whenever the driver wants to issue a read he writes the register offset
and a coockie to the register index register.
The device will write back the data to the MMIO response reg together
with the cokie.

Keep Alive mechanisem:
The device sends to the driver a Keep alive event every 1 sec.
When the driver doesn't receive the keep alive event for a long
period he will try to reset the ena device.


Missing features:
================
 - Rx queue select
 - Ethtool for rxnfs (RFS)
 - CSUM for IPv6
 - counters for failed - sync with sysfs
 - adaptive coalescing
 - update completion head
 - tx_pkt_watchdog proper handeling
 - reset SQ in failure
 - multicast
 - dynamic ring size

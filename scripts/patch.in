#!/bin/bash
#
# build up a git repo while appling the fedora kernel patches
# Author: Cristian Gafton <gafton@amazon.com>

# color in the output helps a lot with parsing
_grn="$(echo -en '\033[1;32m')"  # green
_red="$(echo -en '\033[1;31m')"  # red
_yel="$(echo -en '\033[1;33m')"  # yellow
_def="$(echo -en '\033[0;39m')"  # normal
say_red()    { echo -e "${_red}${1:-}${_def}" ; }
say_green()  { echo -e "${_grn}${1:-}${_def}" ; }
say_yellow() { echo -e "${_yel}${1:-}${_def}" ; }

trap 'say_red "script exited with ERROR: $BASH_COMMAND"' ERR
set -e -x

DEFAULT_AUTHOR="RPM Patch <kernel@fedoraproject.org>"

LINUX_DIR=@@LINUX_DIR@@
VTAG=@@VTAG@@
TAGVER=@@TAGVER@@
UPSTREAM=@@UPSTREAM@@

PATCH_ARGS=
STAGE=patch
while [ $# -gt 0 ] ; do
    case $1 in
        -p* | -F* | -R | -s ) PATCH_ARGS="$PATCH_ARGS $1" ;;
        --start ) STAGE=start ;;
        --finish ) STAGE=finish ;;
        * ) say_yellow "Ignoring patch option: $1" ;;
    esac
    shift
done

# defines we will capture later in the linux.vars file
BRANCH="${UPSTREAM}/${TAGVER}"
TAG="${UPSTREAM}/${TAGVER}/start"

function start_tree {
    # clone out the stable linux tree
    local b=$(basename $(pwd -P))
    pushd ..
    rm -rf $b.git
    git clone --no-hardlinks $LINUX_DIR $b.git
    cd $b.git
    # check that the branch does not already exists
    if ! git show-ref --verify --quiet refs/tags/$VTAG ; then
        say_red "Can not find tag $VTAG"
        exit -1
    fi
    if git show-ref --verify --quiet refs/remotes/origin/$BRANCH ; then
        say_red "Branch $BRANCH already exists"
        exit -1
    fi
    if git show-ref --verify --quiet refs/tags/$TAG ; then
        say_red "Tag $TAG already exists"
        exit -1
    fi
    git checkout -b $BRANCH $VTAG
    popd
    # safety check
    if [ -d ./.git/ ] ; then
        say_red "ERROR: attempting to override internal .git directory with ../$b.git/.git/"
        exit -2
    fi
    # now bring over changes from the unpacked tree
    rsync -aH --delete-after ../$b.git/.git/ ./.git/
    rm -rf ../$b.git
    # now add the changes done by our unpacking...
    git add .
    git commit --quiet --allow-empty -m "start import into $branch"
    git tag $TAG
}

function clean_tree {
    git clean -fdx
}

function commit_tree {
    local msg=${1:-"added patch from stdin"}
    # try to figure out what the patch did...
    git add .
    # also marked as removed in git the stuff that was removed...
    git status --short | grep -E '^.?D' | awk '{print $2}' | xargs -r git rm
    local z=$(git status --short)
    local phead=
    if [ -n "$ptmp" ] ; then
        phead=$(sed -n -r -e '0,/^(--$|diff -|--- )/p;' <$ptmp | \
            sed -r -e 's/^(.*)$/  \1/')
    fi
    if [ -n "${z}" ] ; then 
        cat <<EOF | git commit -s --author="$DEFAULT_AUTHOR" --file=-
${msg}

$(git diff --cached --stat)
${phead}
EOF
    fi
}

function commit_tree_if_needed {
    local msg=$1
    if [ $(git status --short|wc -l) -gt 0 ] ; then
        commit_tree "${msg}"
    fi
}

function finish_tree {
    ptmp=
    topdir=$(git rev-parse --show-toplevel)
    pushd linux-${VTAG##v}* && \
        commit_tree_if_needed "finalized prep"
    clean_tree
    git push origin HEAD && \
        git push origin --tags
    # generate the linux.vers file
    popd
    say_yellow "Updating the linux.vers file..."
    cat >${topdir}/linux.vers <<EOF
linux_TAGVER	= ${VTAG##v}
linux_BASE	= ${TAG}
linux_BRANCH	= ${BRANCH}
linux_HEAD	= \$(linux_BRANCH)
EOF
}

function patch_tree {
    # attempt to save the state of tree changes done via non-patch actions
    # (such as copying stuff in between patches, etc)
    commit_tree_if_needed "pre-patch tree changes $patch"
    clean_tree

    if [ -n "$patch" ] ; then
        if ! git am $ptmp ; then
            if [ -d .git/rebase-apply ] ; then
                git am --abort
            fi
            clean_tree
            /usr/bin/patch $PATCH_ARGS <$ptmp
            commit_tree "imported patch: $patch"
        fi
    else
        /usr/bin/patch $PATCH_ARGS <$ptmp
        commit_tree
    fi
}

###
### MAIN
###
case $STAGE in
    start ) start_tree ;;
    finish ) finish_tree ;;
    patch )
        # capture the stdin into a temp file
        ptmp=$(mktemp $RPM_SOURCE_DIR/pXXXXXX)
        trap "rm -f $ptmp" 0 9 15
        sed -e '/\S/,$!d;' >$ptmp
        if [ ! -d .git ] ; then
            start_tree
        fi
        patch_tree
        rm -f $ptmp
        clean_tree
        ;;
    * )
        say_red "ERROR: unknonw stage: '$STAGE'"
        exit -1
esac
